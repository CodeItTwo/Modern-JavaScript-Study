# 1️⃣ 브라우저 이벤트 소개

## 자주 사용되는 DOM 이벤트

### 마우스 이벤트

- click, contextmenu, mouseover & mouseout, mousedown & mouseup, mousemove

### 폼 요소 이벤트

- submit, focus

### 키보드 이벤트

- keydown, keyup

### 문서 이벤트

- DOMContentLoaded

### CSS 이벤트

- transitionend

## “이벤트는 DOM에만 한정되진 않습니다” 
— 비 DOM 이벤트 예시

- window 객체 이벤트
    - load
    - beforeunload / unload
- 자바스크립트 동작 관련 이벤트
    - Promise 객체의 then이나 catch 같은 콜백 함수
    - WebSocket 통신에서 새로운 메시지가 수신되었을 때 발생하는 이벤트

## 이벤트 핸들러

- 이벤트가 발생했을 때 실행되는 함수
(사용자의 행동에 어떻게 반응할지를 자바 스크립트 코드로 표현한 것)
- 복수의 이벤트 핸들러를 할당할 수 없다(기존 핸들러는 덮어씌워짐)
- 할당방법
1) HTML 속성
2) DOM 프로퍼티
3) addEventListener
- 핸들러 제거하고 싶다면 null 할당해주면 됨
`elem.onclick = null;`

### HTML 속성

- HTML안의 `on<event>` 속성에 핸들러 할당
    
    ```jsx
    <input value="클릭해 주세요." onclick="alert('클릭!')" type="button">
    ```
    
    ex) `onclick`, `onmouseover`, `onkeyup`, `onsubmit`, `onchange` …
    
- 코드가 길다면, 함수를 만들어 호출하도록 함
- HTML 속성은 대소문자를 구분하지 않지만, 대개 onclick 같이 소문자로 작성

### DOM 프로퍼티(HTML + 자바스크립트)

- ex) `elem.onclick`
- DOM프로퍼티는 대소문자를 구분함

### addEventListener / removeEventListener

- 핸들러를 여러개 할당/삭제할 수 있는 방법
- 문법
`element.addEventListener(이벤트 이름, 핸들러 함수, [options]);`
    - `option` — 아래 프로퍼티를 갖는 객체
    `once`: `true`면 이벤트가 트리거 될 때 리스너가 자동으로 삭제됨
    `capture`: 버블링 or 캡쳐링
    `passive`: `true`면 리스너에서 지정한 함수가 `preventDefault()`를 호출하지 않음
- 핸들러를 삭제하려면 핸들러 할당 시 사용한 함수를 그대로 전달해야함
- transitionend와 DOMContentLoaded 같은 일부 이벤트는 addEventListener를 써야만 동작
- 함수 뿐만 아니라 객체를 이벤트 핸들러로 할당할 수 있는데,
이벤트가 발생하면 객체에 구현한 handleEvent 메서드가 호출됨

## this로 요소에 접근하기

- 핸들러 내부의 `this` 값 = 핸들러가 할당된 요소
this 를 사용해 ‘요소 자체’를 참조할 수 있음
- ex)
    
    ```jsx
    <button onclick="alert(this.innerHTML)">클릭해 주세요.</button>
    ```
    
    - this.innerHTML 에서 this는 button

## 자주 하는 실수(주의사항)

1. 함수를 직접 핸들러에 할당할 때, 함수명만 작성해야 함
`button.onclick = sayThanks;` O
`button.onclick = sayThanks();` X
 ( ㄴ 함수 호출의 결괏값이 할당됨 )
그러나, HTML 속성값에는 괄호 있어야함
( ㄴ 브라우저는 속성값을 읽고, 속성값을 함수 본문으로 하는 핸들러 함수를 만들기 때문 )
`<input type="button" id="button" onclick="sayThanks()">`
2. `setAttribute`로 핸들렁 할당하면 안됨

## 이벤트 객체

- 이벤트가 발생하면 브라우저는 이벤트 객체(event object)를 만듦
여기에 이벤트에 관한 상세한 정보를 넣은 다음,
핸들러에 인수 형태로 전달

### 이벤트 객체 프로퍼티

- ex) `.type`, `.currentTarget`, `.clientX` …

# 2️⃣ 버블링과 캡처링

## 버블링

- ‘이벤트 버블링’ 이란?
한 요소에 이벤트가 발생할 때, 가장 최상단의 조상 요소를 만날 때까지 요소 각각에 할당된 핸들러가 동작
- 꼭 필요한 경우가 아니라면 버블링을 막지 않아야 한다

### event.target

- 이벤트 가장 안쪽의 요소는 `target` 요소라 불리며, 
부모 요소 핸들러가 `event.target`을 사용해 접근할 수 있다.
    
    cf) event.currentTarget(=this) — 이벤트를 핸들링하는 현재 요소
    

### 버블링 중단

- `event.stopPropagation()`을 사용하면 핸들러가 이벤트를 완전히 처리한 후 버블링을 중단함
- `event.stopImmediatePropagation()`을 사용하면 한 요소의 특정 이벤트를 처리하는 핸들러가 여러개인 상황에서 핸들러가 모두 동작하지 않음

## 캡처링

- 버블링과 반대
이벤트가 하위 요소로 전파되는 단계
- 캡처링 단계에서 이벤트를 잡아내려면 addEventListener의 capture옵션을 true로 설정해야 함
    
    ```jsx
    elem.addEventListener(..., {capture: true})
    //or
    elem.addEventListener(..., true)
    ```
    
    - false(default값) ⇒ 버블링 단계에서 동작
    true ⇒ 캡처링 단계에서 동작
